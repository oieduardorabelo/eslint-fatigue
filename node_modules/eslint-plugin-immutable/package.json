{
  "_args": [
    [
      "jhusain/eslint-plugin-immutable",
      "/Users/eduardorabelo/Projects/eslint-fatigue"
    ]
  ],
  "_from": "jhusain/eslint-plugin-immutable",
  "_id": "eslint-plugin-immutable@1.0.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/eslint-plugin-immutable",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/jhusain/eslint-plugin-immutable/master/package.json",
      "gitUrl": "git://github.com/jhusain/eslint-plugin-immutable.git",
      "httpsUrl": "git+https://github.com/jhusain/eslint-plugin-immutable.git",
      "shortcut": "github:jhusain/eslint-plugin-immutable",
      "ssh": "git@github.com:jhusain/eslint-plugin-immutable.git",
      "sshUrl": "git+ssh://git@github.com/jhusain/eslint-plugin-immutable.git",
      "type": "github"
    },
    "name": null,
    "raw": "jhusain/eslint-plugin-immutable",
    "rawSpec": "jhusain/eslint-plugin-immutable",
    "scope": null,
    "spec": "github:jhusain/eslint-plugin-immutable",
    "type": "hosted"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "git://github.com/jhusain/eslint-plugin-immutable.git#55043ab338f586b75ae788bc66b27b5fe193edd0",
  "_shasum": "46f81b95e1d82cb46d6d889b48828e457769e689",
  "_shrinkwrap": null,
  "_spec": "jhusain/eslint-plugin-immutable",
  "_where": "/Users/eduardorabelo/Projects/eslint-fatigue",
  "author": {
    "name": "Jafar Husain"
  },
  "bugs": {
    "url": "https://github.com/jhusain/eslint-plugin-immutable/issues"
  },
  "dependencies": {},
  "description": "ESLint plugin to disable all mutation in JavaScript.",
  "devDependencies": {},
  "gitHead": "55043ab338f586b75ae788bc66b27b5fe193edd0",
  "homepage": "https://github.com/jhusain/eslint-plugin-immutable#readme",
  "keywords": [
    "eslint",
    "immutability"
  ],
  "license": "Apache-2.0",
  "main": "index.js",
  "name": "eslint-plugin-immutable",
  "optionalDependencies": {},
  "readme": "# eslint-plugin-immutable\n\nThis is an ESLint plugin to disable all mutation in JavaScript. Think this is a bit too restrictive? Well if you're using Redux and React, there isn't much reason for your code to be mutating *anything*. Redux maintains a mutable pointer to your immutable application state, and React manages your DOM state. Your components should be stateless functions, translating data into Virtual DOM objects whenever Redux emits a new state. These ESLint rules explicitly prohibit mutation, effectively forcing you to write code very similar to [Elm](http://elm-lang.org/) in React.\n\n## Installing\n\n`npm install eslint-plugin-immutable --save-dev`\n\n## ESLint Rules\nThere are three rules in the plugin:\n\n### no-let\n\nThere's no reason to use `let` in a Redux/React application, because all your state is managed by either Redux or React. Use `const` instead, and avoid state bugs altogether.\n\n```JavaScript\nlet x = 5; // <- Unexpected let or var, use const.\n```\n\nWhat about `for` loops? Loops can be replaced with the Array methods like `map`, `filter`, and so on. If you find the built-in JS Array methods lacking, use [lodash](https://github.com/lodash/lodash).\n\n```JavaScript\nconst SearchResults = \n  ({ results }) => \n    <ul>{\n      results.map(result => <li>result</li>) // <- Who needs let?\n    }</ul>;\n```\n\n### no-this\n\nThanks to libraries like [recompose](https://github.com/acdlite/recompose) and Redux's [React Container components](http://redux.js.org/docs/basics/UsageWithReact.html), there's not much reason to build Components using `React.createClass` or ES6 classes anymore. The `no-this` rule makes this explicit.\n\n```JavaScript\nconst Message = React.createClass({\n  render: function() {\n    return <div>{ this.props.message }</div>; // <- no this allowed\n  }\n})\n```\n\nInstead of creating classes, you should use React 0.14's [Stateless Functional Components](https://medium.com/@joshblack/stateless-components-in-react-0-14-f9798f8b992d#.t5z2fdit6) and save yourself some keystrokes:\n\n```JavaScript\nconst Message = ({message}) => <div>{ message }</div>;\n```\n\nWhat about lifecycle methods like `shouldComponentUpdate`? We can use the [recompose](https://github.com/acdlite/recompose) library to apply these optimizations to your Stateless Functional Components. The [recompose](https://github.com/acdlite/recompose) library relies on the fact that your Redux state is immutable to efficiently implement shouldComponentUpdate for you.\n\n```JavaScript\nimport { pure, onlyUpdateForKeys } from 'recompose';\n\nconst Message = ({message}) => <div>{ message }</div>;\n\n// Optimized version of same component, using shallow comparison of props\n// Same effect as React's PureRenderMixin\nconst OptimizedMessage = pure(Message);\n\n// Even more optimized: only updates if specific prop keys have changed\nconst HyperOptimizedMessage = onlyUpdateForKeys(['message'], Message);\n```\n\n### no-mutation\n\nYou might think that prohibiting the use of `let` and `var` would eliminate mutation from your JavaScript code. **Wrong.** Turns out that there's a pretty big loophole in `const`...\n\n```JavaScript\nconst point = { x: 23, y: 44 };\npoint.x = 99; // This is legal\n```\n\nThis is why the `no-mutation` rule exists. This rule prevents you from assigning a value to the result of a member expression.\n\n```JavaScript\nconst point = { x: 23, y: 44 };\npoint.x = 99; // <- No object mutation allowed.\n```\n\nThis rule is just as effective as using Object.freeze() to prevent mutations in your Redux reducers. However this rule has **no run-time cost.** A good alternative to object mutation is to use the object spread syntax coming in ES2016.\n\n```JavaScript\nconst point = { x: 23, y: 44 };\nconst transformedPoint = { ...point, x: 99 };\n```\n\nYou can enable this syntax using the [syntax-object-rest-spread](https://babeljs.io/docs/plugins/syntax-object-rest-spread/) [Babel](https://babeljs.io/) plug-in.\n\n## Supplementary ESLint Rules to Enable\n\nThe rules in this package alone can not eliminate mutation in your JavaScript programs. To go the distance I suggest you also enable the following built-in ESLint rules:\n\n* no-var (self-explanatory)\n* no-undef (prevents assigning to global variables that haven't been declared)\n* no-param-reassign (prevents assigning to variables introduced as function parameters)\n\n## Sample Configuration File\n\nHere's a sample ESLint configuration file that activates these rules:\n\n```\n{\n    \"extends\": \"airbnb\",\n    \"plugins\": [\n        \"immutable\"\n    ],\n    \"rules\": {\n    \t\"immutable/no-let\": 2,\n    \t\"immutable/no-this\": 2,\n    \t\"immutable/no-mutation\": 2\n    }\n}\n```\n\nSpecial Thanks to [cerealbox](https://github.com/cerealbox) who paired with me on this.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jhusain/eslint-plugin-immutable.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "1.0.0"
}
